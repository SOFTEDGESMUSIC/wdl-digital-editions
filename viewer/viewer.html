<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>WDL Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<link rel="stylesheet" href="viewer.css"/>

<!-- PDF.js (self-hosted, paths fixed per your repo) -->
<script src="/wdl-digital-editions/lib/pdfjs/pdf.min.js"></script>
<script src="/wdl-digital-editions/lib/pdfjs/pdf.worker.min.js"></script>
</head>
<body>
<div id="progress"></div>

<div id="viewer">
  <div id="pageWrap">
    <canvas id="pageCanvas"></canvas>
    <div class="edge edge-left"  id="edgePrev"  aria-label="Previous page"><span class="chev">‹</span></div>
    <div class="edge edge-right" id="edgeNext"  aria-label="Next page"><span class="chev">›</span></div>
  </div>
</div>

<div id="controls">
  <button id="prev"      title="Previous page">⟨</button>
  <span id="page-info">1 / ?</span>
  <button id="next"      title="Next page">⟩</button>
  <button id="zoom-out"  title="Zoom out">−</button>
  <button id="zoom-in"   title="Zoom in">+</button>
  <button id="zoom-fit"  title="Fit to window">⤢</button>
  <button id="fullscreen" title="Fullscreen">[ ]</button>
  <!-- ⬇ opens original PDF in new tab (your request) -->
  <a id="openpdf" title="Open PDF in new tab" target="_blank" rel="noopener">⬇</a>
</div>

<script>
(function(){
  // ---------- CONFIG ----------
  const DEFAULT_PDF = "/wdl-digital-editions/editions/WDL210825Merged.pdf";
  const urlParam = new URLSearchParams(location.search).get("pdf");
  const pdfURL = urlParam || DEFAULT_PDF;

  // ---------- ELEMENTS ----------
  const viewer   = document.getElementById("viewer");
  const wrap     = document.getElementById("pageWrap");
  const canvas   = document.getElementById("pageCanvas");
  const ctx      = canvas.getContext("2d");
  const progress = document.getElementById("progress");
  const pageInfo = document.getElementById("page-info");
  const edgePrev = document.getElementById("edgePrev");
  const edgeNext = document.getElementById("edgeNext");
  const openpdf  = document.getElementById("openpdf");
  openpdf.href   = pdfURL;

  // ---------- STATE ----------
  let pdfDoc=null, current=1, total=0, zoom=1;
  let minZoom=1, maxZoom=1; // min = fit whole page; max = fit-to-width
  const DPR = Math.max(1, window.devicePixelRatio||1);

  function setProgress(p){
    if (p > 0 && p < 1) progress.classList.add('active'); else progress.classList.remove('active');
    progress.style.width = (p*100) + '%';
  }

  function box(){
    return { vw: viewer.clientWidth, vh: viewer.clientHeight };
  }

  async function renderPage(num, anchor){
    const page = await pdfDoc.getPage(num);

    const {vw, vh} = box();
    const vp1 = page.getViewport({scale:1});

    // Fit scales
    const fitWhole = Math.min(vw / vp1.width, vh / vp1.height); // show whole page (no crop)
    const fitWidth = vw / vp1.width;                             // page fills width; vertical scroll

    // Keep current zoom within [fitWhole, fitWidth]
    // Represent zoom as multiplier of fitWhole (minZoom=1)
    minZoom = 1;
    maxZoom = Math.max(1, fitWidth / fitWhole);
    zoom = Math.min(Math.max(zoom, minZoom), maxZoom);

    const scale = fitWhole * zoom;
    const vp = page.getViewport({scale});

    const cssW = Math.floor(vp.width);
    const cssH = Math.floor(vp.height);

    // Preserve visual center (or provided anchor) across resizes/zooms
    let rx = (viewer.scrollLeft + viewer.clientWidth/2) / Math.max(1, wrap.clientWidth);
    let ry = (viewer.scrollTop  + viewer.clientHeight/2) / Math.max(1, wrap.clientHeight);
    if (anchor && typeof anchor.rx === 'number') { rx = anchor.rx; }
    if (anchor && typeof anchor.ry === 'number') { ry = anchor.ry; }

    // Size canvas (CSS pixels)
    canvas.style.width  = cssW + "px";
    canvas.style.height = cssH + "px";
    wrap.style.width    = cssW + "px";
    wrap.style.height   = cssH + "px";

    // Render at HiDPI for crisp text
    const out = DPR;
    canvas.width  = Math.floor(cssW * out);
    canvas.height = Math.floor(cssH * out);

    setProgress(0.15);
    await page.render({
      canvasContext: ctx,
      transform: out !== 1 ? [out,0,0,out,0,0] : null,
      viewport: vp
    }).promise;
    setProgress(1);

    // Restore scroll to center/anchor
    const newW = wrap.clientWidth, newH = wrap.clientHeight;
    const targetLeft = Math.max(0, rx * newW - viewer.clientWidth/2);
    const targetTop  = Math.max(0, ry * newH - viewer.clientHeight/2);
    viewer.scrollLeft = targetLeft;
    viewer.scrollTop  = targetTop;

    pageInfo.textContent = `${num} / ${total}`;
  }

  async function loadPDF(url){
    setProgress(0.01);
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/wdl-digital-editions/lib/pdfjs/pdf.worker.min.js";
    const task = pdfjsLib.getDocument({ url });
    task.onProgress = (e)=>{ if (e && e.total) setProgress(Math.min(0.9, e.loaded/e.total)); };
    const doc = await task.promise;
    setProgress(0.98);
    return doc;
  }

  async function goTo(n){
    current = Math.max(1, Math.min(total, n));
    await renderPage(current);
  }

  async function zoomTo(newZoom, anchorPx){
    // newZoom is relative to minZoom (fitWhole) multiplier
    // clamp to [minZoom, maxZoom]; anchor zoom around pointer if given
    newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
    let anchor=null;
    if (anchorPx){
      const cw = wrap.clientWidth, ch = wrap.clientHeight;
      const cx = viewer.scrollLeft + anchorPx.x;
      const cy = viewer.scrollTop  + anchorPx.y;
      anchor = { rx: cw ? cx/cw : 0.5, ry: ch ? cy/ch : 0.5 };
    }
    zoom = newZoom;
    await renderPage(current, anchor);
  }

  // ---------- Events ----------
  // Buttons
  document.getElementById('prev').onclick     = ()=>goTo(current-1);
  document.getElementById('next').onclick     = ()=>goTo(current+1);
  document.getElementById('zoom-in').onclick  = ()=>zoomTo(zoom*1.2, {x:viewer.clientWidth/2, y:viewer.clientHeight/2});
  document.getElementById('zoom-out').onclick = ()=>zoomTo(zoom/1.2, {x:viewer.clientWidth/2, y:viewer.clientHeight/2});
  document.getElementById('zoom-fit').onclick = ()=>zoomTo(minZoom, {x:viewer.clientWidth/2, y:viewer.clientHeight/2});

  // Fullscreen with fallbacks; if blocked, open PDF in new tab
  document.getElementById('fullscreen').onclick = ()=>{
    const el = viewer;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || el.mozRequestFullScreen;
    if (req) {
      try { req.call(el); } catch { window.open(pdfURL, '_blank', 'noopener'); }
    } else {
      window.open(pdfURL, '_blank', 'noopener');
    }
  };

  // Keyboard arrows turn pages
  window.addEventListener('keydown', (e)=>{
    if (e.target && /input|textarea|select/i.test(e.target.tagName)) return;
    if (e.key === 'ArrowLeft')  { e.preventDefault(); goTo(current-1); }
    if (e.key === 'ArrowRight') { e.preventDefault(); goTo(current+1); }
  });

  // Wheel zoom (ctrl/trackpad pinch); clamp to fit-width
  viewer.addEventListener('wheel', (e)=>{
    if (e.ctrlKey){
      e.preventDefault();
      const rect = viewer.getBoundingClientRect();
      const anchor = { x:e.clientX-rect.left, y:e.clientY-rect.top };
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      zoomTo(zoom*factor, anchor);
    }
  }, {passive:false});

  // Edge clicks turn pages
  edgePrev.addEventListener('click', ()=>goTo(current-1));
  edgeNext.addEventListener('click', ()=>goTo(current+1));

  // Resize keeps current zoom target within bounds
  window.addEventListener('resize', ()=>renderPage(current));

  // ---------- Boot ----------
  (async function(){
    try{
      pdfDoc = await loadPDF(pdfURL);
      total  = pdfDoc.numPages;
      await renderPage(current);
    }catch(err){
      console.error('PDF load error', err);
      setProgress(1);
    }
  })();
})();
</script>
</body>
</html>
