<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>WDL Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<link rel="stylesheet" href="viewer.css"/>

<!-- PDF.js (self-hosted) -->
<script src="/wdl-digital-editions/lib/pdfjs/pdf.min.js"></script>
<script src="/wdl-digital-editions/lib/pdfjs/pdf.worker.min.js"></script>
</head>
<body>
<div id="progress"></div>

<div id="viewer" aria-label="Document viewport">
  <div id="pageWrap">
    <canvas id="pageCanvas"></canvas>

    <!-- Click zones (light grey chevrons) -->
    <div class="edge edge-left"  id="edgePrev" aria-label="Previous page"><span class="chev">â€¹</span></div>
    <div class="edge edge-right" id="edgeNext" aria-label="Next page"><span class="chev">â€º</span></div>
  </div>
</div>

<!-- Slim control bar under the viewer -->
<div id="controls" role="toolbar" aria-label="Document controls">
  <button id="prev"      title="Previous page" aria-label="Previous page">âŸ¨</button>
  <span id="page-info" aria-live="polite">1 / ?</span>
  <button id="next"      title="Next page" aria-label="Next page">âŸ©</button>

  <button id="zoom-out"  title="Zoom out" aria-label="Zoom out">âˆ’</button>
  <button id="zoom-in"   title="Zoom in"  aria-label="Zoom in">+</button>

  <!-- Toggle Fit/Page Width â€” icon only (no text) -->
  <button id="zoom-toggle" title="Toggle Fit/Page Width" aria-label="Toggle Fit â†” Width">â†”</button>

  <!-- Open PDF in a new tab (down arrow) -->
  <a id="openpdf" title="Open PDF in new tab" target="_blank" rel="noopener" aria-label="Open PDF">â¬‡</a>
</div>

<script>
(() => {
  // ---------- CONFIG ----------
  // Override via ?pdf=/wdl-digital-editions/editions/Whatever.pdf
  const DEFAULT_PDF = "/wdl-digital-editions/editions/latest.pdf";
  const params = new URLSearchParams(location.search);
  const pdfURL = params.get("pdf") || params.get("file") || DEFAULT_PDF;

  // ---------- ELEMENTS ----------
  const viewer   = document.getElementById("viewer");
  const wrap     = document.getElementById("pageWrap");
  const canvas   = document.getElementById("pageCanvas");
  const ctx      = canvas.getContext("2d", { alpha:false });
  const progress = document.getElementById("progress");
  const pageInfo = document.getElementById("page-info");
  const edgePrev = document.getElementById("edgePrev");
  const edgeNext = document.getElementById("edgeNext");
  const openpdf  = document.getElementById("openpdf");
  openpdf.href   = pdfURL;

  // ---------- STATE ----------
  let pdfDoc = null, current = 1, total = 0;
  let zoom = 1;               // zoom is a multiplier on "fit-to-page" scale
  let minZoom = 1, maxZoom = 1;
  let fitMode = "page";       // "page" or "width"
  let firstRenderDone = false;

  const DPR = Math.max(1, window.devicePixelRatio || 1);
  const isMobile = () => matchMedia("(max-width: 840px)").matches;

  // ---------- HELPERS ----------
  const setProgress = p => {
    if (p > 0 && p < 1) progress.classList.add('active'); else progress.classList.remove('active');
    progress.style.width = (p * 100) + '%';
  };
  const box = () => ({ vw: viewer.clientWidth, vh: viewer.clientHeight });

  // Fit computation and bounds
  function computeFit(vp1) {
  const { vw, vh } = box();
  const fitWhole = Math.min(vw / vp1.width, vh / vp1.height);
  const fitWidth = vw / vp1.width;
  const baseWidthZoom = fitWidth / fitWhole;

  // ðŸ‘‡ First render default: desktop = width, mobile = page
  if (!firstRenderDone) {
    fitMode = isMobile() ? "page" : "width";
    zoom = (fitMode === "width") ? baseWidthZoom : 1;
  }

  // Bounds (desktop caps at fit-width; mobile allows 2Ã— beyond)
  minZoom = 1;
  maxZoom = isMobile() ? Math.max(baseWidthZoom, baseWidthZoom * 2) : Math.max(1, baseWidthZoom);
  zoom = Math.min(Math.max(zoom, minZoom), maxZoom);

  return { fitWhole, baseWidthZoom };
}
  async function renderPage(num, anchor) {
    const page = await pdfDoc.getPage(num);
    const vp1  = page.getViewport({ scale: 1 });
    const { fitWhole } = computeFit(vp1);

    // Compute CSS size of canvas for current zoom
    const scale = fitWhole * zoom;
    const vp = page.getViewport({ scale });
    const cssW = Math.floor(vp.width);
    const cssH = Math.floor(vp.height);

    // Preserve center/anchor across renders
    let rx = (viewer.scrollLeft + viewer.clientWidth / 2) / Math.max(1, wrap.clientWidth);
    let ry = (viewer.scrollTop  + viewer.clientHeight / 2) / Math.max(1, wrap.clientHeight);

    // First render or page change: anchor to TOP-CENTER
    if (!firstRenderDone || anchor === "top-center") { rx = 0.5; ry = 0.0; }
    // Custom anchor from zoom/pinch
    if (anchor && typeof anchor.rx === "number") rx = anchor.rx;
    if (anchor && typeof anchor.ry === "number") ry = anchor.ry;

    // Size canvas (CSS)
    canvas.style.width  = cssW + "px";
    canvas.style.height = cssH + "px";
    wrap.style.width    = cssW + "px";
    wrap.style.height   = cssH + "px";

    // Hi-DPI render for crisp text
    const out = DPR;
    canvas.width  = Math.floor(cssW * out);
    canvas.height = Math.floor(cssH * out);

    setProgress(0.12);
    await page.render({
      canvasContext: ctx,
      transform: out !== 1 ? [out, 0, 0, out, 0, 0] : null,
      viewport: vp
    }).promise;
    setProgress(1);

    // Restore scroll to center/anchor
    const newW = wrap.clientWidth, newH = wrap.clientHeight;
    viewer.scrollLeft = Math.max(0, rx * newW - viewer.clientWidth / 2);
    viewer.scrollTop  = Math.max(0, ry * newH - viewer.clientHeight / 2);

    pageInfo.textContent = `${num} / ${total}`;
    firstRenderDone = true;
  }

  async function loadPDF(url) {
    setProgress(0.01);
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/wdl-digital-editions/lib/pdfjs/pdf.worker.min.js";
    const task = pdfjsLib.getDocument({ url });
    task.onProgress = e => { if (e && e.total) setProgress(Math.min(0.9, e.loaded / e.total)); };
    const doc = await task.promise;
    setProgress(0.98);
    return doc;
  }

  async function goTo(n) {
    current = Math.max(1, Math.min(total, n));
    await renderPage(current, "top-center");
  }

  async function zoomTo(newZoom, anchorPx) {
    const { vw, vh } = box();
    const cw = wrap.clientWidth, ch = wrap.clientHeight;

    newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));

    let anchor = null;
    if (anchorPx) {
      const cx = viewer.scrollLeft + anchorPx.x;
      const cy = viewer.scrollTop  + anchorPx.y;
      anchor = { rx: cw ? cx / cw : 0.5, ry: ch ? cy / ch : 0.5 };
    }
    zoom = newZoom;
    await renderPage(current, anchor);
  }

  async function toggleFitMode() {
    // Recompute fit values from current page to get the correct baseWidthZoom
    const page = await pdfDoc.getPage(current);
    const vp1  = page.getViewport({ scale: 1 });
    const { fitWhole, baseWidthZoom } = computeFit(vp1);

    fitMode = (fitMode === "page") ? "width" : "page";
    const targetZoom = (fitMode === "width") ? baseWidthZoom : 1;

    // Anchor around center of viewport
    await zoomTo(targetZoom, { x: viewer.clientWidth / 2, y: viewer.clientHeight / 2 });
  }

  // ---------- Controls ----------
  document.getElementById('prev').onclick      = () => goTo(current - 1);
  document.getElementById('next').onclick      = () => goTo(current + 1);
  document.getElementById('zoom-in').onclick   = () => zoomTo(zoom * 1.2, { x: viewer.clientWidth / 2, y: viewer.clientHeight / 2 });
  document.getElementById('zoom-out').onclick  = () => zoomTo(zoom / 1.2, { x: viewer.clientWidth / 2, y: viewer.clientHeight / 2 });
  document.getElementById('zoom-toggle').onclick = () => { toggleFitMode(); };

  // Keyboard arrows turn pages
  window.addEventListener('keydown', (e) => {
    if (e.target && /input|textarea|select/i.test(e.target.tagName)) return;
    if (e.key === 'ArrowLeft')  { e.preventDefault(); goTo(current - 1); }
    if (e.key === 'ArrowRight') { e.preventDefault(); goTo(current + 1); }
  });

  // Edge clicks turn pages
  edgePrev.addEventListener('click', () => goTo(current - 1));
  edgeNext.addEventListener('click', () => goTo(current + 1));

  // Pointer gestures: pinch-to-zoom (mobile) and drag-to-pan when zoomed
  const active = new Map(); // pointerId -> {x,y}
  let startDist = 0, startZoom = 1, anchorPE = null;
  let panning = false, panId = null, panStart = { x: 0, y: 0 }, panScroll = { l: 0, t: 0 };

  const pePoint = e => ({ x: e.clientX, y: e.clientY });
  const peDist  = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
  const peMid   = (a, b, rect) => ({ x: ((a.x + b.x) / 2 - rect.left), y: ((a.y + b.y) / 2 - rect.top) });

  function onPointerDown(e) {
    if (e.target.closest('#controls') || e.target.closest('.edge')) return;

    active.set(e.pointerId, pePoint(e));

    // Start pinch
    if (active.size === 2) {
      const pts  = Array.from(active.values());
      const rect = viewer.getBoundingClientRect();
      startDist = peDist(pts[0], pts[1]);
      startZoom = zoom;
      anchorPE  = peMid(pts[0], pts[1], rect);
      panning   = false; panId = null;
      e.preventDefault();
      return;
    }

    // Start pan only if zoomed in
    if (active.size === 1 && zoom > minZoom) {
      panning = true; panId = e.pointerId;
      panStart  = pePoint(e);
      panScroll = { l: viewer.scrollLeft, t: viewer.scrollTop };
      if (viewer.setPointerCapture) viewer.setPointerCapture(e.pointerId);
      e.preventDefault();
    }
  }

  function onPointerMove(e) {
    if (!active.has(e.pointerId)) return;
    active.set(e.pointerId, pePoint(e));

    // Pinch zoom
    if (active.size === 2 && startDist > 0) {
      const pts = Array.from(active.values());
      const d   = peDist(pts[0], pts[1]);
      const factor = d / startDist;
      zoomTo(startZoom * factor, anchorPE);
      e.preventDefault();
      return;
    }

    // Pan
    if (panning && e.pointerId === panId) {
      const pt = pePoint(e);
      viewer.scrollLeft = panScroll.l - (pt.x - panStart.x);
      viewer.scrollTop  = panScroll.t - (pt.y - panStart.y);
      e.preventDefault();
    }
  }

  function onPointerUp(e) {
    active.delete(e.pointerId);
    if (active.size < 2) { startDist = 0; anchorPE = null; }
    if (e.pointerId === panId) { panning = false; panId = null; }
  }

  viewer.addEventListener('pointerdown', onPointerDown, { passive: false });
  viewer.addEventListener('pointermove', onPointerMove, { passive: false });
  viewer.addEventListener('pointerup',   onPointerUp,   { passive: false });
  viewer.addEventListener('pointercancel', onPointerUp, { passive: false });
  viewer.addEventListener('pointerleave',  onPointerUp, { passive: false });

  // Wheel zoom (desktop trackpad pinch)
  viewer.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      const rect = viewer.getBoundingClientRect();
      const anchor = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      const factor = e.deltaY < 0 ? 1.12 : 0.9;
      zoomTo(zoom * factor, anchor);
    }
  }, { passive: false });

  // Double-click (desktop) & double-tap (mobile): toggle fit modes at current center
  function doToggleAtPointer(clientX, clientY) {
    const rect = viewer.getBoundingClientRect();
    toggleFitMode().then(() => {/* already centers around viewport mid in toggleFitMode */});
  }
  viewer.addEventListener('dblclick', (e) => { e.preventDefault(); doToggleAtPointer(e.clientX, e.clientY); });

  let lastTap = 0;
  viewer.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (e.changedTouches.length === 1 && (now - lastTap) < 300) {
      doToggleAtPointer(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    }
    lastTap = now;
  }, { passive: true });

  // Resize => re-render keeping center
  window.addEventListener('resize', () => { renderPage(current); });

  // ---------- Boot ----------
  loadPDF(pdfURL)
    .then(doc => { pdfDoc = doc; total = doc.numPages; return renderPage(current, "top-center"); })
    .catch(err => { console.error("PDF load error", err); progress.classList.remove('active'); });
})();
</script>
</body>
</html>
