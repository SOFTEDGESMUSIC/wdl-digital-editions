<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>WDL Viewer</title>

  <!-- Your minimal viewer styles -->
  <link rel="stylesheet" href="../viewer/viewer.css" />

  <!-- PDF.js (self-hosted) -->
  <script src="../lib/pdfjs/pdf.min.js"></script>
  <script>
    // point PDF.js worker at your self-hosted worker
    if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = "../lib/pdfjs/pdf.worker.min.js";
    }
  </script>
</head>
<body>
  <div id="wdl-app">
    <div id="wdl-toolbar">
      <button id="btnPrev" title="Previous page">◀</button>
      <span id="pageInfo"><span id="pageNum">1</span>/<span id="pageCount">1</span></span>
      <button id="btnNext" title="Next page">▶</button>

      <span class="spacer"></span>

      <button id="btnZoomOut" title="Zoom out">−</button>
      <button id="btnFit" title="Fit to height">Fit</button>
      <button id="btnZoomIn" title="Zoom in">+</button>

      <span class="spacer"></span>

      <a id="btnDownload" href="#" download>Download</a>
      <button id="btnFull" title="Fullscreen">⤢</button>
    </div>

    <div id="wdl-stage">
      <!-- scrollable viewport -->
      <div id="viewport">
        <!-- canvas + selectable text layer -->
        <canvas id="pdfCanvas"></canvas>
        <div id="textLayer" class="textLayer"></div>
      </div>
    </div>

    <div id="wdl-status" aria-live="polite">Loading…</div>
  </div>

  <script>
  (function () {
    const params = new URLSearchParams(location.search);
    let file = params.get("file"); // e.g. /wdl-digital-editions/editions/WDL210825Merged.pdf

    // If no ?file=, try to read /latest.json at repo root (one level up from /viewer/)
    async function resolveFileIfMissing() {
      if (file) return file;
      try {
        const r = await fetch("../latest.json", { cache: "no-store" });
        const meta = await r.json();
        if (meta && meta.pdf) {
          // allow "editions/xxx.pdf" or "/editions/xxx.pdf"
          return meta.pdf.startsWith("/")
            ? meta.pdf
            : "../" + meta.pdf;
        }
      } catch (e) {
        console.warn("latest.json not found or invalid", e);
      }
      throw new Error("No PDF specified (add ?file=… or provide latest.json).");
    }

    // DOM
    const E = (id) => document.getElementById(id);
    const els = {
      stage: E("wdl-stage"),
      view: E("viewport"),
      canvas: E("pdfCanvas"),
      textLayer: E("textLayer"),
      status: E("wdl-status"),
      btnPrev: E("btnPrev"),
      btnNext: E("btnNext"),
      btnZoomIn: E("btnZoomIn"),
      btnZoomOut: E("btnZoomOut"),
      btnFit: E("btnFit"),
      btnFull: E("btnFull"),
      pageNum: E("pageNum"),
      pageCount: E("pageCount"),
      btnDownload: E("btnDownload"),
    };

    const DPR = Math.max(1, window.devicePixelRatio || 1);
    let pdfDoc = null;
    let currentPage = 1;
    let pageCount = 1;
    let fitScale = 1;       // scale that fits height
    let scale = 1;          // actual render scale (zooms around fitScale)
    let rendering = false;
    let pendingPage = null;

    function setStatus(s) { els.status.textContent = s; }

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    function setDownloadHref(url) {
      els.btnDownload.href = url;
    }

    // Compute the "fit to height" scale so the whole page fits vertically
    async function computeFitScale(page) {
      const viewport1 = page.getViewport({ scale: 1 });
      const viewH = els.view.clientHeight || window.innerHeight * 0.8;
      fitScale = (viewH) / viewport1.height;
      // Start a touch sharper than perfect fit
      fitScale *= 1.02;
      scale = fitScale;
    }

    async function renderPage(num) {
      rendering = true;
      setStatus(`Rendering page ${num}…`);

      const page = await pdfDoc.getPage(num);

      // If this is the first render or after resize, compute fit scale
      if (!fitScale) await computeFitScale(page);

      const viewport = page.getViewport({ scale: scale * DPR });

      // Canvas setup
      const ctx = els.canvas.getContext("2d", { alpha: false });
      els.canvas.width = Math.floor(viewport.width);
      els.canvas.height = Math.floor(viewport.height);
      els.canvas.style.width = Math.floor(viewport.width / DPR) + "px";
      els.canvas.style.height = Math.floor(viewport.height / DPR) + "px";

      // Clear and size text layer
      els.textLayer.innerHTML = "";
      els.textLayer.style.width = els.canvas.style.width;
      els.textLayer.style.height = els.canvas.style.height;

      // Render page to canvas
      await page.render({ canvasContext: ctx, viewport }).promise;

      // Render selectable text layer (crisp vector glyphs)
      if (pdfjsLib.renderTextLayer) {
        const textContent = await page.getTextContent();
        await pdfjsLib.renderTextLayer({
          textContent,
          container: els.textLayer,
          viewport: page.getViewport({ scale: scale }), // textLayer uses CSS pixels (no DPR)
          textDivs: [],
          enhanceTextSelection: true,
        }).promise;
      }

      // update UI
      els.pageNum.textContent = String(num);
      rendering = false;
      setStatus("Ready");

      // handle queued page
      if (pendingPage !== null) {
        const p = pendingPage; pendingPage = null;
        queueRender(p);
      }
    }

    function queueRender(num) {
      if (rendering) {
        pendingPage = num;
      } else {
        renderPage(num);
      }
    }

    function changePage(delta) {
      const target = clamp(currentPage + delta, 1, pageCount);
      if (target !== currentPage) {
        currentPage = target;
        queueRender(currentPage);
      }
    }

    // Zoom around the current center
    function setZoom(newScale) {
      newScale = clamp(newScale, fitScale * 0.5, fitScale * 5);
      if (Math.abs(newScale - scale) < 0.001) return;

      // keep visual center position stable
      const rect = els.view.getBoundingClientRect();
      const cx = els.view.scrollLeft + rect.width / 2;
      const cy = els.view.scrollTop + rect.height / 2;
      const relX = cx / (parseFloat(els.canvas.style.width) || 1);
      const relY = cy / (parseFloat(els.canvas.style.height) || 1);

      scale = newScale;
      queueRender(currentPage);

      // after render completes, scroll back near same relative point
      setTimeout(() => {
        const w = parseFloat(els.canvas.style.width) || 0;
        const h = parseFloat(els.canvas.style.height) || 0;
        els.view.scrollLeft = Math.max(0, w * relX - rect.width / 2);
        els.view.scrollTop = Math.max(0, h * relY - rect.height / 2);
      }, 0);
    }

    // Fit to height (respect toolbar)
    function fitToHeight() {
      fitScale = 0; // force recompute on next render
      queueRender(currentPage);
    }

    // Mouse wheel zoom (Ctrl/⌘ + wheel)
    els.view.addEventListener("wheel", (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const dir = e.deltaY > 0 ? -1 : 1;
        const step = scale * (dir > 0 ? 0.1 : -0.1);
        setZoom(scale + step);
      }
    }, { passive: false });

    // Drag-to-pan
    let drag = false, sx = 0, sy = 0, sl = 0, st = 0;
    els.view.addEventListener("mousedown", (e) => {
      drag = true; sx = e.clientX; sy = e.clientY; sl = els.view.scrollLeft; st = els.view.scrollTop;
      els.view.style.cursor = "grabbing";
      e.preventDefault();
    });
    window.addEventListener("mousemove", (e) => {
      if (!drag) return;
      els.view.scrollLeft = sl - (e.clientX - sx);
      els.view.scrollTop  = st - (e.clientY - sy);
    });
    window.addEventListener("mouseup", () => { drag = false; els.view.style.cursor = "default"; });

    // Buttons
    els.btnPrev.onclick = () => changePage(-1);
    els.btnNext.onclick = () => changePage(1);
    els.btnZoomIn.onclick  = () => setZoom(scale * 1.15);
    els.btnZoomOut.onclick = () => setZoom(scale / 1.15);
    els.btnFit.onclick = fitToHeight;
    els.btnFull.onclick = () => {
      document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen();
    };

    // Resize → keep “fit to height” behaviour
    window.addEventListener("resize", () => fitToHeight());

    // Boot
    (async () => {
      try {
        const resolved = await resolveFileIfMissing();
        // If they passed a relative path like "/editions/…", make it relative to this html
        const absolute = resolved.startsWith("http") ? resolved : new URL(resolved, location.href).href;
        setDownloadHref(absolute);

        setStatus("Loading…");
        pdfDoc = await pdfjsLib.getDocument({ url: absolute }).promise;
        pageCount = pdfDoc.numPages;
        els.pageCount.textContent = String(pageCount);
        currentPage = 1;
        fitToHeight(); // will queue render
      } catch (err) {
        console.error(err);
        setStatus("Failed to load PDF.");
      }
    })();
  })();
  </script>
</body>
</html>
